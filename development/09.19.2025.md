Roadmap Overview

  - Align existing workflow-stack (server/routes/workflow.ts, client/src/components/workbench,
  client/src/hooks) with Valor‑IVX mock’s tri-pane IDE.
  - Preserve optimistic state/version tooling while redesigning layout, navigation, and AI
  affordances.

  Phase 0 – Discovery & Foundations

  - Capture current UX gaps: map mockup zones (TopBar, Explorer, WorkbenchTabs, Inspector,
  Console) against client/src/components/workbench/WorkbenchLayout.tsx, stage-tabs.tsx,
  MemoComposer.tsx.
  - Extend shared types for new UI primitives (chip variants, task items, evidence cards) under
  @shared/types.
  - Draft design tokens (colors, spacing) ensuring Tailwind config covers gradient transparencies
  used in render.

  Phase 1 – Shell & Navigation

  - Rebuild top-level layout component to support fixed TopBar, left Explorer, right Inspector,
  bottom Console; ensure responsive behavior per spec.
  - Replace current tab system with mock-inspired multi-tab Workbench, binding STAGES order to
  routing (client/src/pages/workflow-stage.tsx).
  - Introduce Omni-Prompt form and Next-stage actions; connect to existing presence/conflict
  hooks (useMemoComposer/usePresence).

  Phase 2 – Pane Content Parity

  - Left Explorer: implement pipeline list with completion state (leveraging workflow state
  events) and objects/saved views sections.
  - Workbench content: convert mock components (HomeDailyBrief, Intake, Screener, etc.) into
  modular React files under client/src/components/workbench/stages/ with real data wiring where
  available (Normalization, Valuation, Monitoring hooks).
  - Inspector panel: integrate AI Pair Analyst prompt history, evidence list, audit trail using
  existing fetchWorkflowHistory and research log endpoints.

  Phase 3 – Console & Prompt History

  - Build bottom console component capturing Omni-Prompt submissions, reusing presence/history
  event streams.
  - Map tasks list to existing checklist data or new task model (shared schema addition; update
  server storage if persistence needed later).

  Phase 4 – Interaction & State Integration

  - Wire Next button to stage advancement logic, maintaining optimistic concurrency (server/
  routes/workflow.ts: upsertState) and stage completion records.
  - Add real-time presence badges aligned with Inspector/Audit visuals, reusing usePresence.
  - Synchronize prompt submissions with AI service (via workflow-api) once backend available;
  store in new prompt history table.

  Phase 5 – Styling & Accessibility

  - Implement shared Chip component with tone variants; ensure focus states and keyboard
  navigation for Explorer, tabs, buttons.
  - Apply typography, colors, and spacing per mock (tailwind classes), verifying light/dark
  compliance if required.

  Phase 6 – Testing & Validation

  - Expand Vitest suites: layout snapshot tests, stage component smoke tests (client/test/
  integration), presence/console behavior.
  - Add Cypress or Playwright scripts for tri-pane interactions and Omni-Prompt flows.

  Phase 7 – Documentation & Release

  - Update docs/workflow-audit-collaboration.md with new IDE architecture, Omni-Prompt flow, and
  Inspector features.
  - Record migration plan for database-backed prompt history/tasks before production cutover.

  Suggested Next Steps

  1. Prototype new layout shell in a feature branch (scaffold components per mock, static data).
  2. Define data contracts for Inspector/Console (prompt history, audit entries) and extend
  shared schema.
  3. Plan integration points for each stage component with existing hooks to avoid regressions.

▌ Explain this codebase                                                                          